

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon-32x32.png">
  <link rel="icon" href="/img/favicon-32x32.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="叶">
  <meta name="keywords" content="">
  
    <meta name="description" content="npm init vue@latest  创建一个应用实例应用实例每个 vue 应用都是通过 createAPP 函数创建一个新的应用实例： 12345import &amp;#123; createApp &amp;#125; from &quot;vue&quot;;const app &#x3D; createApp(&amp;#123;  &#x2F;* 根组件选项 *&#x2F;&amp;#125;);  需要给 createApp 的对象实际上">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue基础">
<meta property="og:url" content="https://www.yygod0120.com/2023/06/08/Vue/index.html">
<meta property="og:site_name" content="Ye&#39;s Blog">
<meta property="og:description" content="npm init vue@latest  创建一个应用实例应用实例每个 vue 应用都是通过 createAPP 函数创建一个新的应用实例： 12345import &amp;#123; createApp &amp;#125; from &quot;vue&quot;;const app &#x3D; createApp(&amp;#123;  &#x2F;* 根组件选项 *&#x2F;&amp;#125;);  需要给 createApp 的对象实际上">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.yygod0120.com/images/Vue.jpg">
<meta property="article:published_time" content="2023-06-08T11:56:43.000Z">
<meta property="article:modified_time" content="2023-08-25T07:42:24.307Z">
<meta property="article:author" content="叶">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.yygod0120.com/images/Vue.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Vue基础 - Ye&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.yygod0120.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<!-- hexo injector head_end start --><style type="text/css">span[class="simple-icon"]{width:1.2rem;height:1.2rem;display:inline-block}span[class="simple-icon"] svg,img{display:inline-block;vertical-align:middle;height:inherit;width:inherit}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>YE</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://images.unsplash.com/photo-1677946060093-7c9f0208dab1?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1228&q=80') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Vue基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-08 19:56" pubdate>
          2023年6月8日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          268 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Vue基础</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年8月25日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>npm init vue@latest</p>
</blockquote>
<h1 id="创建一个应用实例"><a href="#创建一个应用实例" class="headerlink" title="创建一个应用实例"></a>创建一个应用实例</h1><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>每个 vue 应用都是通过 createAPP 函数创建一个新的应用实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;<br>  <span class="hljs-comment">/* 根组件选项 */</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>需要给 createApp 的对象实际上是一个组件,每个运用都需要一个”根组件”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-comment">// 从一个单文件组件中导入根组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br></code></pre></td></tr></table></figure>

<h2 id="挂载运用"><a href="#挂载运用" class="headerlink" title="挂载运用"></a>挂载运用</h2><p>应用实例必须在调用了 .mount() 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>.mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。</p>
<h2 id="多个运用实例"><a href="#多个运用实例" class="headerlink" title="多个运用实例"></a>多个运用实例</h2><p>应用实例并不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app1 = <span class="hljs-title function_">createApp</span>(&#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;);<br>app1.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#container-1&quot;</span>);<br><br><span class="hljs-keyword">const</span> app2 = <span class="hljs-title function_">createApp</span>(&#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;);<br>app2.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#container-2&quot;</span>);<br></code></pre></td></tr></table></figure>

<h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p>Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。</p>
<h2 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h2><p>最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;<br>&lt;span&gt;Message: &#123;&#123; number + 1 &#125;&#125;&lt;/span&gt; //11<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">export default &#123; data()&#123; return &#123; msg:&quot;xxx&quot;, number:&#x27;10&#x27; &#125; &#125; &#125;<br></code></pre></td></tr></table></figure>

<p>双大括号中也可以使用 JS 逻辑运算(需要有返回值)</p>
<h2 id="原始-template"><a href="#原始-template" class="headerlink" title="原始 template"></a>原始 template</h2><p>双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;<br>&lt;p&gt;Using v-template directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;<br></code></pre></td></tr></table></figure>

<h2 id="Attribute-特性-绑定"><a href="#Attribute-特性-绑定" class="headerlink" title="Attribute(特性) 绑定"></a>Attribute(特性) 绑定</h2><p>双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 v-bind 指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>可以简写为<code>:id</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h3 id="布尔型-Attribute"><a href="#布尔型-Attribute" class="headerlink" title="布尔型 Attribute"></a>布尔型 Attribute</h3><p>布尔型 attribute 依据 true / false 值来决定 attribute 是否应该存在于该元素上。disabled 就是最常见的例子之一。<br>v-bind 在这种场景下的行为略有不同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p>当 isButtonDisabled 为真值或一个空字符串 (即 <code>&lt;button disabled=&quot;&quot;&gt;</code>) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。</p>
<h3 id="动态绑定多个值"><a href="#动态绑定多个值" class="headerlink" title="动态绑定多个值"></a>动态绑定多个值</h3><p>如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">objectOfAttrs</span>: &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;container&#x27;</span>,<br>      <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;wrapper&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过不带参数的 v-bind，你可以将它们绑定到单个元素上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h3 id="使用-JS-表达式"><a href="#使用-JS-表达式" class="headerlink" title="使用 JS 表达式"></a>使用 JS 表达式</h3><p>至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&#123;&#123; number + 1 &#125;&#125; &#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125; &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)<br>&#125;&#125;<br><br>&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。</p>
<p>在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：</p>
<ul>
<li>在文本插值中 (双大括号)</li>
<li>在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中</li>
</ul>
<blockquote>
<p>每个绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 这是一个语句，而非表达式 --&gt;<br>&#123;&#123; var a = 1 &#125;&#125;<br><br>&lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;<br>&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>可以在绑定的表达式中使用一个组件暴露的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;time :title=&quot;toTitleDate(date)&quot; :datetime=&quot;date&quot;&gt;<br>  &#123;&#123; formatDate(date) &#125;&#125;<br>&lt;/time&gt;<br></code></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是带有 v- 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上我们所介绍的 v-bind 和 v-template。<br>指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 v-for、v-on 和 v-slot)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。<br>以 v-if 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;<br></code></pre></td></tr></table></figure>

<p>这里，v-if 指令会基于表达式 seen 的值的真假来移除/插入该 <code>&lt;p&gt;</code> 元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p v-show=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;<br></code></pre></td></tr></table></figure>

<h3 id="参数-Argument"><a href="#参数-Argument" class="headerlink" title="参数 Argument"></a>参数 Argument</h3><p>某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 v-bind 指令来响应式地更新一个 HTML attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure>

<p>另一个例子是 v-on 指令，它将监听 DOM 事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure>

<h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p>同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!--<br>注意，参数表达式有一些约束，<br>参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释<br>--&gt;<br>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;<br></code></pre></td></tr></table></figure>

<p>这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 attributeName，其值为 “href”，那么这个绑定就等价于 v-bind:href。</p>
<p>相似地，你还可以将一个函数绑定到动态的事件名称上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;<br><br>&lt;!-- 简写 --&gt;<br>&lt;a @[eventName]=&quot;doSomething&quot;&gt;&lt;/a&gt;<br></code></pre></td></tr></table></figure>

<p>在此示例中，当 eventName 的值是 “focus” 时，v-on:[eventName] 就等价于 v-on:focus。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;<br></code></pre></td></tr></table></figure>

<h1 id="声明响应式状态"><a href="#声明响应式状态" class="headerlink" title="声明响应式状态"></a>声明响应式状态</h1><p>我们可以使用 reactive() 函数创建一个响应式对象或数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br></code></pre></td></tr></table></figure>

<p>响应式对象其实是 JavaScript Proxy，其行为表现与一般对象相似。不同之处在于 Vue 能够跟踪对响应式对象属性的访问与更改操作。</p>
<p>要在组件模板中使用响应式状态，需要在 setup() 函数中定义并返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// `setup` 是一个专门用于组合式 API 的特殊钩子函数</span><br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br><br>    <span class="hljs-comment">// 暴露 state 到模板</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      state,<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div&gt;&#123;&#123; state.count &#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>自然，我们也可以在同一个作用域下定义更新响应式状态的函数，并将他们作为方法与状态一起暴露出去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      state.<span class="hljs-property">count</span>++;<br>    &#125;<br><br>    <span class="hljs-comment">// 不要忘记同时暴露 increment 函数</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      state,<br>      increment,<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="lt-script-setup-gt"><a href="#lt-script-setup-gt" class="headerlink" title="&lt;script setup&gt;"></a><code>&lt;script setup&gt;</code></h2><p>在 setup() 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。当使用单文件组件（SFC）时，我们可以使用 <code>&lt;script setup&gt;</code> 来大幅度地简化代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;script setup&gt;<br>  import &#123; reactive &#125; from &quot;vue&quot;;<br><br>  const state = reactive(&#123; count: 0 &#125;);<br><br>  function increment() &#123;<br>    state.count++;<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; state.count &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h2 id="reactive-的局限性"><a href="#reactive-的局限性" class="headerlink" title="reactive()的局限性"></a><code>reactive()</code>的局限性</h2><p>reactive() API 有两条限制：</p>
<ol>
<li>仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。</li>
<li>因为 Vue 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br><br><span class="hljs-comment">// 上面的引用 (&#123; count: 0 &#125;) 将不再被追踪（响应性连接已丢失！）</span><br>state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;);<br></code></pre></td></tr></table></figure>

<h2 id="用ref-定义响应式遍变量"><a href="#用ref-定义响应式遍变量" class="headerlink" title="用ref()定义响应式遍变量"></a>用<code>ref()</code>定义响应式遍变量</h2><p>为此，Vue 提供了一个 ref() 方法来允许我们创建可以使用任何值类型的响应式 ref：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>ref() 将传入参数的值包装为一个带 .value 属性的 ref 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// &#123; value: 0 &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>); <span class="hljs-comment">// 0</span><br><br>count.<span class="hljs-property">value</span>++;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>简言之，ref() 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。这个功能很重要，因为它经常用于将逻辑提取到 组合函数 中。</p>
<h2 id="ref在模板中的解包"><a href="#ref在模板中的解包" class="headerlink" title="ref在模板中的解包"></a><code>ref</code>在模板中的解包</h2><p>当 ref 在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用 .value。下面是之前的计数器例子，用 ref() 代替：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref &#125; from &quot;vue&quot;;<br><br>const count = ref(0);<br><br>function increment() &#123;<br>  count.value++;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;<br>    &#123;&#123; count &#125;&#125;<br>    &lt;!-- 无需 .value --&gt;<br>  &lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>请注意，仅当 ref 是模板渲染上下文的顶层属性时才适用自动“解包”。</p>
</blockquote>
<h2 id="ref在响应式对象中的解包"><a href="#ref在响应式对象中的解包" class="headerlink" title="ref在响应式对象中的解包"></a><code>ref</code>在响应式对象中的解包</h2><p>当一个 ref 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现得和一般的属性一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  count,<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>); <span class="hljs-comment">// 0</span><br><br>state.<span class="hljs-property">count</span> = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-comment">//如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：</span><br><span class="hljs-keyword">const</span> otherCount = <span class="hljs-title function_">ref</span>(<span class="hljs-number">2</span>);<br><br>state.<span class="hljs-property">count</span> = otherCount;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 原始 ref 现在已经和 state.count 失去联系</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<h2 id="数组和集合类型的-ref-解包"><a href="#数组和集合类型的-ref-解包" class="headerlink" title="数组和集合类型的 ref 解包"></a>数组和集合类型的 ref 解包</h2><p>跟响应式对象不同，当 ref 作为响应式数组或像 Map 这种原生集合类型的元素被访问时，不会进行解包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> books = <span class="hljs-title function_">reactive</span>([<span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;Vue 3 Guide&quot;</span>)]);<br><span class="hljs-comment">// 这里需要 .value</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(books[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>);<br><br><span class="hljs-keyword">const</span> map = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)]]));<br><span class="hljs-comment">// 这里需要 .value</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;count&quot;</span>).<span class="hljs-property">value</span>);<br></code></pre></td></tr></table></figure>

<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> author = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-attr">books</span>: [<br>    <span class="hljs-string">&quot;Vue 2 - Advanced Guide&quot;</span>,<br>    <span class="hljs-string">&quot;Vue 3 - Basic Guide&quot;</span>,<br>    <span class="hljs-string">&quot;Vue 4 - The Mystery&quot;</span>,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>我们想根据 author 是否已有一些书籍来展示不同的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p&gt;Has published books:&lt;/p&gt;<br>&lt;span&gt;&#123;&#123; author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure>

<p>这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 author.books。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。</p>
<p>因此我们推荐使用计算属性来描述依赖响应式状态的复杂逻辑。这是重构后的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; reactive, computed &#125; from &quot;vue&quot;;<br><br>const author = reactive(&#123;<br>  name: &quot;John Doe&quot;,<br>  books: [<br>    &quot;Vue 2 - Advanced Guide&quot;,<br>    &quot;Vue 3 - Basic Guide&quot;,<br>    &quot;Vue 4 - The Mystery&quot;,<br>  ],<br>&#125;);<br><br>// 一个计算属性 ref<br>const publishedBooksMessage = computed(() =&gt; &#123;<br>  return author.books.length &gt; 0 ? &quot;Yes&quot; : &quot;No&quot;;<br>&#125;);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;p&gt;Has published books:&lt;/p&gt;<br>  &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>我们在这里定义了一个计算属性 publishedBooksMessage。computed() 方法期望接收一个 getter 函数，返回值为一个计算属性 ref。和其他一般的 ref 类似，你可以通过 publishedBooksMessage.value 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。</p>
<h2 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h2><p>计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, computed &#125; from &quot;vue&quot;;<br><br>const firstName = ref(&quot;John&quot;);<br>const lastName = ref(&quot;Doe&quot;);<br><br>const fullName = computed(&#123;<br>  // getter<br>  get() &#123;<br>    return firstName.value + &quot; &quot; + lastName.value;<br>  &#125;,<br>  // setter<br>  set(newValue) &#123;<br>    // 注意：我们这里使用的是解构赋值语法<br>    [firstName.value, lastName.value] = newValue.split(&quot; &quot;);<br>  &#125;,<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="Getter-不应该有副作用"><a href="#Getter-不应该有副作用" class="headerlink" title="Getter 不应该有副作用"></a>Getter 不应该有副作用</h3><p>计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，<strong>不要在 getter 中做异步请求或者更改 DOM！</strong>一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用监听器根据其他响应式状态的变更来创建副作用。</p>
<h3 id="避免直接修改计算属性值"><a href="#避免直接修改计算属性值" class="headerlink" title="避免直接修改计算属性值"></a>避免直接修改计算属性值</h3><p>从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</p>
<h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><p>数据绑定的一个常见需求场景是操纵元素的 CSS class 列表和内联样式。</p>
<h2 id="绑定-HTML-class"><a href="#绑定-HTML-class" class="headerlink" title="绑定 HTML class"></a>绑定 HTML class</h2><h3 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h3><p>我们可以给 :class (v-bind:class 的缩写) 传递一个对象来动态切换 class</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>上面的语法表示 active 是否存在取决于数据属性 isActive 的真假值。</p>
<p>你可以在对象中写多个字段来操作多个 class。此外，:class 指令也可以和一般的 class attribute 共存。举例来说，下面这样的状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> isActive = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">const</span> hasError = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>

<p>配合以下模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div<br>  class=&quot;static&quot;<br>  :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;<br>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>渲染的结果会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>绑定的对象并不一定需要写成内联字面量的形式，也可以直接绑定一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> classObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-string">&quot;active&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;text-danger&quot;</span>: <span class="hljs-literal">false</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>我们也可以绑定一个返回对象的计算属性。这是一个常见且很有用的技巧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> isActive = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">const</span> classObject = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-attr">active</span>: isActive.<span class="hljs-property">value</span> &amp;&amp; !error.<span class="hljs-property">value</span>,<br>  <span class="hljs-string">&quot;text-danger&quot;</span>: error.<span class="hljs-property">value</span> &amp;&amp; error.<span class="hljs-property">value</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;fatal&quot;</span>,<br>&#125;));<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h3 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h3><p>我们可以给 :class 绑定一个数组来渲染多个 CSS class：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> activeClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;active&quot;</span>);<br><span class="hljs-keyword">const</span> errorClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;text-danger&quot;</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>渲染的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="绑定对象-1"><a href="#绑定对象-1" class="headerlink" title="绑定对象"></a>绑定对象</h3><p>:style 支持绑定 JavaScript 对象值，对应的是 HTML 元素的 style 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> activeColor = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;red&quot;</span>);<br><span class="hljs-keyword">const</span> fontSize = <span class="hljs-title function_">ref</span>(<span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>尽管推荐使用 camelCase，但 :style 也支持 kebab-cased 形式的 CSS 属性 key (对应其 CSS 中的实际名称)，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;&#123; &#x27;font-size&#x27;: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> styleObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span>,<br>  <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;13px&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>同样的，如果样式对象需要更复杂的逻辑，也可以使用返回样式对象的计算属性。</p>
<h3 id="绑定数组-1"><a href="#绑定数组-1" class="headerlink" title="绑定数组"></a>绑定数组</h3><p>我们还可以给 :style 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;<br></code></pre></td></tr></table></figure>

<h2 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h2><p>你也可以使用 v-else 为 v-if 添加一个“else 区块”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt;<br><br>&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;<br>&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;<br></code></pre></td></tr></table></figure>

<h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><p>顾名思义，v-else-if 提供的是相应于 v-if 的“else if 区块”。它可以连续多次重复使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;A&lt;/div&gt;<br>&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;B&lt;/div&gt;<br>&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;C&lt;/div&gt;<br>&lt;div v-else&gt;Not A/B/C&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h2 id="lt-template-gt-上的-v-if"><a href="#lt-template-gt-上的-v-if" class="headerlink" title="&lt;template&gt; 上的 v-if"></a><code>&lt;template&gt;</code> 上的 v-if</h2><p>因为 v-if 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 v-if，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 <code>&lt;template&gt;</code> 元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;template v-if=&quot;ok&quot;&gt;<br>  &lt;h1&gt;Title&lt;/h1&gt;<br>  &lt;p&gt;Paragraph 1&lt;/p&gt;<br>  &lt;p&gt;Paragraph 2&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>v-else 和 v-else-if 也可以在 <code>&lt;template&gt;</code> 上使用。</p>
</blockquote>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>另一个可以用来按条件显示一个元素的指令是 v-show。其用法基本一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;<br></code></pre></td></tr></table></figure>

<p>不同之处在于 v-show 会在 DOM 渲染中保留该元素；v-show 仅切换了该元素上名为 display 的 CSS 属性。</p>
<p>v-show 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 v-else 搭配使用。</p>
<h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a><code>v-if</code> vs <code>v-show</code></h2><p>v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</p>
<p>v-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</p>
<p>相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。</p>
<p>总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。</p>
<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>我们可以使用 v-for 指令基于一个数组来渲染一个列表。v-for 指令的值需要使用 item in items 形式的特殊语法，其中 items 是源数据的数组，而 item 是迭代项的别名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> items = <span class="hljs-title function_">ref</span>([&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Foo&quot;</span> &#125;, &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Bar&quot;</span> &#125;]);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123; item.message &#125;&#125;&lt;/li&gt;<br></code></pre></td></tr></table></figure>

<p>在 v-for 块中可以完整地访问父作用域内的属性和变量。v-for 也支持使用可选的第二个参数表示当前项的位置索引。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parentMessage = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;Parent&quot;</span>);<br><span class="hljs-keyword">const</span> items = <span class="hljs-title function_">ref</span>([&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Foo&quot;</span> &#125;, &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Bar&quot;</span> &#125;]);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;(item, index) in items&quot;&gt;<br>  &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>Parent-0-Foo</li>
<li>Parent-1-Bar</li>
</ul>
<hr>
<p>你也可以在定义 v-for 的变量别名时使用解构，和解构函数参数类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;&#123; message &#125; in items&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/li&gt;<br><br>&lt;!-- 有 index 索引时 --&gt;<br>&lt;li v-for=&quot;(&#123; message &#125;, index) in items&quot;&gt;&#123;&#123; message &#125;&#125; &#123;&#123; index &#125;&#125;&lt;/li&gt;<br></code></pre></td></tr></table></figure>

<p>对于多层嵌套的 v-for，作用域的工作方式和函数的作用域很类似。每个 v-for 作用域都可以访问到父级作用域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;item in items&quot;&gt;<br>  &lt;span v-for=&quot;childItem in item.children&quot;&gt;<br>    &#123;&#123; item.message &#125;&#125; &#123;&#123; childItem &#125;&#125;<br>  &lt;/span&gt;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure>

<p>你也可以使用 of 作为分隔符来替代 in，这更接近 JavaScript 的迭代器语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h2 id="v-for-与对象"><a href="#v-for-与对象" class="headerlink" title="v-for 与对象"></a>v-for 与对象</h2><p>你也可以使用 v-for 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 Object.keys() 的返回值来决定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;How to do lists in Vue&quot;</span>,<br>  <span class="hljs-attr">author</span>: <span class="hljs-string">&quot;Jane Doe&quot;</span>,<br>  <span class="hljs-attr">publishedAt</span>: <span class="hljs-string">&quot;2016-04-10&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;ul&gt;<br>  &lt;li v-for=&quot;value in myObject&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure>

<p>可以通过提供第二个参数表示属性名 (例如 key)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;(value, key) in myObject&quot;&gt;&#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt;<br></code></pre></td></tr></table></figure>

<p>第三个参数表示位置索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt;<br>  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure>

<h2 id="在-v-for-里使用范围值"><a href="#在-v-for-里使用范围值" class="headerlink" title="在 v-for 里使用范围值"></a>在 v-for 里使用范围值</h2><p>v-for 可以直接接受一个整数值。在这种用例中，会将该模板基于 1…n 的取值范围重复多次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意此处 n 的初值是从 1 开始而非 0</p>
</blockquote>
<h2 id="lt-template-gt-上的-v-for"><a href="#lt-template-gt-上的-v-for" class="headerlink" title="&lt;template&gt; 上的 v-for"></a><code>&lt;template&gt;</code> 上的 v-for</h2><p>与模板上的 v-if 类似，你也可以在 <code>&lt;template&gt;</code> 标签上使用 v-for 来渲染一个包含多个元素的块。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;ul&gt;<br>  &lt;template v-for=&quot;item in items&quot;&gt;<br>    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;<br>    &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt;<br>  &lt;/template&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure>

<h2 id="v-if-和-v-for"><a href="#v-if-和-v-for" class="headerlink" title="v-if 和 v-for"></a>v-if 和 v-for</h2><p>当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!--<br> 这会抛出一个错误，因为属性 todo 此时<br> 没有在该实例上定义<br>--&gt;<br>&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;&#123;&#123; todo.name &#125;&#125;&lt;/li&gt;<br></code></pre></td></tr></table></figure>

<p>在外新包装一层 <code>&lt;template&gt;</code> 再在其上使用 v-for 可以解决这个问题 (这也更加明显易读)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;template v-for=&quot;todo in todos&quot;&gt;<br>  &lt;li v-if=&quot;!todo.isComplete&quot;&gt;&#123;&#123; todo.name &#125;&#125;&lt;/li&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h2 id="通过-key-管理状态"><a href="#通过-key-管理状态" class="headerlink" title="通过 key 管理状态"></a>通过 key 管理状态</h2><p>Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。</p>
<p>默认模式是高效的，但<strong>只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。</strong></p>
<p>为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 key attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;<br>  &lt;!-- 内容 --&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>当你使用 <code>&lt;template v-for&gt;</code> 时，key 应该被放置在这个 <code>&lt;template&gt;</code> 容器上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;template v-for=&quot;todo in todos&quot; :key=&quot;todo.name&quot;&gt;<br>  &lt;li&gt;&#123;&#123; todo.name &#125;&#125;&lt;/li&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>推荐在任何可行的时候为 v-for 提供一个 key attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。</p>
<h2 id="数组变化预测"><a href="#数组变化预测" class="headerlink" title="数组变化预测"></a>数组变化预测</h2><h3 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h3><p>Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<h3 id="替换一个数组"><a href="#替换一个数组" class="headerlink" title="替换一个数组"></a>替换一个数组</h3><p>变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变 (immutable) 方法，例如 filter()，concat() 和 slice()，这些都不会更改原数组，而总是返回一个新数组。当遇到的是非变更方法时，我们需要将旧的数组替换为新的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// `items` 是一个数组的 ref</span><br>items.<span class="hljs-property">value</span> = items.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">message</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/Foo/</span>));<br></code></pre></td></tr></table></figure>

<p>你可能认为这将导致 Vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。Vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作。</p>
<h2 id="展示过滤或排序后的结果"><a href="#展示过滤或排序后的结果" class="headerlink" title="展示过滤或排序后的结果"></a>展示过滤或排序后的结果</h2><p>有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性(使用 filter )。<br>在计算属性中使用 reverse() 和 sort() 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- return numbers.reverse()</span><br><span class="hljs-addition">+ return [...numbers].reverse()</span><br></code></pre></td></tr></table></figure>

<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>我们可以使用 v-on 指令 (简写为 @) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。用法：<code>v-on:click=&quot;handler&quot;</code> 或 <code>@click=&quot;handler&quot;</code>。<br>事件处理器 (handler) 的值可以是：</p>
<ol>
<li><strong>内联事件处理器：</strong>事件被触发时执行的内联 JavaScript 语句 (与 onclick 类似)。</li>
<li><strong>方法事件处理器：</strong>一个指向组件上定义的方法的属性名或是路径。</li>
</ol>
<h3 id="内联事件处理器"><a href="#内联事件处理器" class="headerlink" title="内联事件处理器"></a>内联事件处理器</h3><p>内联事件处理器通常用于简单场景，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;button @click=&quot;count++&quot;&gt;Add 1&lt;/button&gt;<br>&lt;p&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/p&gt;<br></code></pre></td></tr></table></figure>

<h3 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h3><p>随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 v-on 也可以接受一个方法名或对某个方法的调用。</p>
<p>举例来说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;Vue.js&quot;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name.value&#125;</span>!`</span>);<br>  <span class="hljs-comment">// `event` 是 DOM 原生事件</span><br>  <span class="hljs-keyword">if</span> (event) &#123;<br>    <span class="hljs-title function_">alert</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- `greet` 是上面定义过的方法名 --&gt;<br>&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p>方法事件处理器会自动接收原生 DOM 事件并触发执行。在上面的例子中，我们能够通过被触发事件的 event.target.tagName 访问到该 DOM 元素。</p>
<h3 id="方法与内联事件判断"><a href="#方法与内联事件判断" class="headerlink" title="方法与内联事件判断"></a>方法与内联事件判断</h3><p>模板编译器会通过检查 v-on 的值是否是合法的 JavaScript 标识符或属性访问路径来断定是何种形式的事件处理器。举例来说，foo、foo.bar 和 foo[‘bar’] 会被视为方法事件处理器，而 foo() 和 count++ 会被视为内联事件处理器。</p>
<h2 id="在内联处理器中调用方法"><a href="#在内联处理器中调用方法" class="headerlink" title="在内联处理器中调用方法"></a>在内联处理器中调用方法</h2><p>除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">message</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;button @click=&quot;say(&#x27;hello&#x27;)&quot;&gt;Say hello&lt;/button&gt;<br>&lt;button @click=&quot;say(&#x27;bye&#x27;)&quot;&gt;Say bye&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<h2 id="在内联事件处理器中访问事件参数"><a href="#在内联事件处理器中访问事件参数" class="headerlink" title="在内联事件处理器中访问事件参数"></a>在内联事件处理器中访问事件参数</h2><p>有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 $event 变量，或者使用内联箭头函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 使用特殊的 $event 变量 --&gt;<br>&lt;button @click=&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;&gt;Submit&lt;/button&gt;<br><br>&lt;!-- 使用内联箭头函数 --&gt;<br>&lt;button @click=&quot;(event) =&gt; warn(&#x27;Form cannot be submitted yet.&#x27;, event)&quot;&gt;<br>  Submit<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warn</span>(<span class="hljs-params">message, event</span>) &#123;<br>  <span class="hljs-comment">// 这里可以访问原生事件</span><br>  <span class="hljs-keyword">if</span> (event) &#123;<br>    event.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br>  <span class="hljs-title function_">alert</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在处理事件时调用 event.preventDefault() 或 event.stopPropagation() 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。</p>
<p>为解决这一问题，Vue 为 v-on 提供了事件修饰符。修饰符是用 . 表示的指令后缀，包含以下这些：</p>
<ul>
<li>.stop</li>
<li>.prevent</li>
<li>.self</li>
<li>.capture</li>
<li>.once</li>
<li>.passive</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 单击事件将停止传递 --&gt;<br>&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;<br><br>&lt;!-- 提交事件将不再重新加载页面 --&gt;<br>&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;<br><br>&lt;!-- 修饰语可以使用链式书写 --&gt;<br>&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;<br><br>&lt;!-- 也可以只有修饰符 --&gt;<br>&lt;form @submit.prevent&gt;&lt;/form&gt;<br><br>&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;<br>&lt;!-- 例如：事件处理器不来自子元素 --&gt;<br>&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 @click.prevent.self 会阻止元素及其子元素的所有点击事件的默认行为，而 @click.self.prevent 则只会阻止对元素本身的点击事件的默认行为。</p>
</blockquote>
<p>.capture、.once 和 .passive 修饰符与原生 addEventListener 事件相对应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 添加事件监听器时，使用 `capture` 捕获模式 --&gt;<br>&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;<br>&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;<br><br>&lt;!-- 点击事件最多被触发一次 --&gt;<br>&lt;a @click.once=&quot;doThis&quot;&gt;&lt;/a&gt;<br><br>&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 --&gt;<br>&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;<br>&lt;div @scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>.passive 修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。</p>
</blockquote>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 v-on 或 @ 监听按键事件时添加按键修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;<br>&lt;input @keyup.enter=&quot;submit&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>你可以直接使用 KeyboardEvent.key 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;<br>&lt;input @keyup.page-down=&quot;onPageDown&quot; /&gt;<br></code></pre></td></tr></table></figure>

<h3 id="按键别名"><a href="#按键别名" class="headerlink" title="按键别名"></a>按键别名</h3><p>Vue 为一些常用的按键提供了别名：</p>
<ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete (捕获“Delete”和“Backspace”两个按键)</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
</ul>
<h3 id="系统按键修饰符"><a href="#系统按键修饰符" class="headerlink" title="系统按键修饰符"></a>系统按键修饰符</h3><p>你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。</p>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
<p>举例来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- Alt + Enter --&gt;<br>&lt;input @keyup.alt.enter=&quot;clear&quot; /&gt;<br><br>&lt;!-- Ctrl + 点击 --&gt;<br>&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h3 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a>.exact 修饰符</h3><p>.exact 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;<br>&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;<br><br>&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;<br>&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;<br><br>&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;<br>&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<h2 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h2><ul>
<li>.left</li>
<li>.right</li>
<li>.middle</li>
</ul>
<p>这些修饰符将处理程序限定为由特定鼠标按键触发的事件。</p>
<h1 id="表单输入输出"><a href="#表单输入输出" class="headerlink" title="表单输入输出"></a>表单输入输出</h1><p>在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input :value=&quot;text&quot; @input=&quot;event =&gt; text = event.target.value&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>v-model 指令帮我们简化了这一步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input v-model=&quot;text&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>另外，v-model 还可以用于各种不同类型的输入，<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 元素。它会根据所使用的元素自动使用对应的 DOM 属性和事件组合：</p>
<ul>
<li>文本类型的 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素会绑定 value property 并侦听 input 事件；</li>
<li><code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;&gt;</code> 会绑定 checked property 并侦听 change 事件；</li>
<li><code>&lt;select&gt;</code> 会绑定 value property 并侦听 change 事件。</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;<br>&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot; /&gt;<br></code></pre></td></tr></table></figure>

<h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;span&gt;Multiline message is:&lt;/span&gt;<br>&lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;<br></code></pre></td></tr></table></figure>

<p>注意在 <code>&lt;textarea&gt;</code> 中是不支持插值表达式的。请使用 v-model 来替代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 错误 --&gt;<br>&lt;textarea&gt;&#123;&#123; text &#125;&#125;&lt;/textarea&gt;<br><br>&lt;!-- 正确 --&gt;<br>&lt;textarea v-model=&quot;text&quot;&gt;&lt;/textarea&gt;<br></code></pre></td></tr></table></figure>

<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>单一的复选框，绑定布尔类型值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot; /&gt;<br>&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;<br></code></pre></td></tr></table></figure>

<p>我们也可以将多个复选框绑定到同一个数组或集合的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> checkedNames = <span class="hljs-title function_">ref</span>([]);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/div&gt;<br><br>&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot; /&gt;<br>&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;<br><br>&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot; /&gt;<br>&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;<br><br>&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot; /&gt;<br>&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，checkedNames 数组将始终包含所有当前被选中的框的值。</p>
<h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/div&gt;<br><br>&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot; /&gt;<br>&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;<br><br>&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot; /&gt;<br>&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;<br></code></pre></td></tr></table></figure>

<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>单个选择器的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;<br><br>&lt;select v-model=&quot;selected&quot;&gt;<br>  &lt;option disabled value=&quot;&quot;&gt;Please select one&lt;/option&gt;<br>  &lt;option&gt;A&lt;/option&gt;<br>  &lt;option&gt;B&lt;/option&gt;<br>  &lt;option&gt;C&lt;/option&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure>

<p>多选 (值绑定到一个数组)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;<br><br>&lt;select v-model=&quot;selected&quot; multiple&gt;<br>  &lt;option&gt;A&lt;/option&gt;<br>  &lt;option&gt;B&lt;/option&gt;<br>  &lt;option&gt;C&lt;/option&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure>

<p>选择器的选项可以使用 v-for 动态渲染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> selected = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;A&#x27;</span>)<br><br><span class="hljs-keyword">const</span> options = <span class="hljs-title function_">ref</span>([<br>  &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;One&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;A&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Two&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;B&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Three&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;C&#x27;</span> &#125;<br>])<span class="hljs-string">``</span><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;select v-model=&quot;selected&quot;&gt;<br>  &lt;option v-for=&quot;option in options&quot; :value=&quot;option.value&quot;&gt;<br>    &#123;&#123; option.text &#125;&#125;<br>  &lt;/option&gt;<br>&lt;/select&gt;<br><br>&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h2 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h2><p>对于单选按钮，复选框和选择器选项，v-model 绑定的值通常是静态的字符串 (或者对复选框是布尔值)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- `picked` 在被选择时是字符串 &quot;a&quot; --&gt;<br>&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot; /&gt;<br><br>&lt;!-- `toggle` 只会为 true 或 false --&gt;<br>&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; /&gt;<br><br>&lt;!-- `selected` 在第一项被选中时为字符串 &quot;abc&quot; --&gt;<br>&lt;select v-model=&quot;selected&quot;&gt;<br>  &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure>

<p>但有时我们可能希望将该值绑定到当前组件实例上的动态数据。这可以通过使用 v-bind 来实现。此外，使用 v-bind 还使我们可以将选项值绑定为非字符串的数据类型。</p>
<h3 id="复选框-1"><a href="#复选框-1" class="headerlink" title="复选框"></a>复选框</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>true-value 和 false-value 是 Vue 特有的 attributes，仅支持和 v-model 配套使用。这里 toggle 属性的值会在选中时被设为 ‘yes’，取消选择时设为 ‘no’。你同样可以通过 v-bind 将其绑定为其他动态值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input<br>  type=&quot;checkbox&quot;<br>  v-model=&quot;toggle&quot;<br>  :true-value=&quot;dynamicTrueValue&quot;<br>  :false-value=&quot;dynamicFalseValue&quot;<br>/&gt;<br></code></pre></td></tr></table></figure>

<h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;first&quot; /&gt;<br>&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;second&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>pick 会在第一个按钮选中时被设为 first，在第二个按钮选中时被设为 second。</p>
<h3 id="选择器选项"><a href="#选择器选项" class="headerlink" title="选择器选项"></a>选择器选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;select v-model=&quot;selected&quot;&gt;<br>  &lt;!-- 内联对象字面量 --&gt;<br>  &lt;option :value=&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;/option&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure>

<p>v-model 同样也支持非字符串类型的值绑定！在上面这个例子中，当某个选项被选中，selected 会被设为该对象字面量值 { number: 123 }。</p>
<h2 id="修饰符-1"><a href="#修饰符-1" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h3><p>默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 lazy 修饰符来改为在每次 change 事件后更新数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 在 &quot;change&quot; 事件后同步更新而不是 &quot;input&quot; --&gt;<br>&lt;input v-model.lazy=&quot;msg&quot; /&gt;<br></code></pre></td></tr></table></figure>

<h3 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h3><p>如果你想让用户输入自动转换为数字，你可以在 v-model 后添加 .number 修饰符来管理输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input v-model.number=&quot;age&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>如果该值无法被 parseFloat() 处理，那么将返回原始值。</p>
<p>number 修饰符会在输入框有 type=”number” 时自动启用。</p>
<h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h3><p>如果你想要默认自动去除用户输入内容中两端的空格，你可以在 v-model 后添加 .trim 修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input v-model.trim=&quot;msg&quot; /&gt;<br></code></pre></td></tr></table></figure>

<h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p>每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。</p>
<h2 id="注册周期钩子"><a href="#注册周期钩子" class="headerlink" title="注册周期钩子"></a>注册周期钩子</h2><p>举例来说，onMounted 钩子可以用来在组件完成初始渲染并创建 DOM 节点后运行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;script setup&gt;<br>  import &#123; onMounted &#125; from &quot;vue&quot;;<br><br>  onMounted(() =&gt; &#123;<br>    console.log(`the component is now mounted.`);<br>  &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>当调用 onMounted 时，Vue 会自动将回调函数注册到当前正被初始化的组件实例上。这意味着这些钩子应当在组件初始化时被同步注册。例如，请不要这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 异步注册时当前组件实例已丢失</span><br>    <span class="hljs-comment">// 这将不会正常工作</span><br>  &#125;);<br>&#125;, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<p>注意这并不意味着对 onMounted 的调用必须放在 setup() 或 <code>&lt;script setup&gt;</code> 内的词法上下文中。<code>onMounted()</code> 也可以在一个外部函数中调用，只要调用栈是同步的，且最终起源自 <code>setup()</code> 就可以。</p>
<h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><img src="../Vue/life_round_api.png" srcset="/img/loading.gif" lazyload alt="生命周期" width="500" height="500">

<p>想了解更多生命周期钩子 api 的用法，请参考<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/composition-api-lifecycle.template">生命周期钩子 API 索引</a></p>
<h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>在组合式 API 中，我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, watch &#125; from &quot;vue&quot;;<br><br>const question = ref(&quot;&quot;);<br>const answer = ref(&quot;Questions usually contain a question mark. ;-)&quot;);<br><br>// 可以直接侦听一个 ref<br>watch(question, async (newQuestion, oldQuestion) =&gt; &#123;<br>  if (newQuestion.indexOf(&quot;?&quot;) &gt; -1) &#123;<br>    answer.value = &quot;Thinking...&quot;;<br>    try &#123;<br>      const res = await fetch(&quot;https://yesno.wtf/api&quot;);<br>      answer.value = (await res.json()).answer;<br>    &#125; catch (error) &#123;<br>      answer.value = &quot;Error! Could not reach the API. &quot; + error;<br>    &#125;<br>  &#125;<br>&#125;);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;p&gt;<br>    Ask a yes/no question:<br>    &lt;input v-model=&quot;question&quot; /&gt;<br>  &lt;/p&gt;<br>  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>现在可能还看不懂这些代码，先往下读</p>
<h2 id="侦听数据源类型"><a href="#侦听数据源类型" class="headerlink" title="侦听数据源类型"></a>侦听数据源类型</h2><p>watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 单个 ref</span><br><span class="hljs-title function_">watch</span>(x, <span class="hljs-function">(<span class="hljs-params">newX</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`x is <span class="hljs-subst">$&#123;newX&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// getter 函数</span><br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> x.<span class="hljs-property">value</span> + y.<span class="hljs-property">value</span>,<br>  <span class="hljs-function">(<span class="hljs-params">sum</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`sum of x + y is: <span class="hljs-subst">$&#123;sum&#125;</span>`</span>);<br>  &#125;<br>);<br><br><span class="hljs-comment">// 多个来源组成的数组</span><br><span class="hljs-title function_">watch</span>([x, <span class="hljs-function">() =&gt;</span> y.<span class="hljs-property">value</span>], <span class="hljs-function">(<span class="hljs-params">[newX, newY]</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`x is <span class="hljs-subst">$&#123;newX&#125;</span> and y is <span class="hljs-subst">$&#123;newY&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>注意，你不能直接侦听响应式对象的属性值，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br><br><span class="hljs-comment">// 错误，因为 watch() 得到的参数是一个 number</span><br><span class="hljs-title function_">watch</span>(obj.<span class="hljs-property">count</span>, <span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count is: <span class="hljs-subst">$&#123;count&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这里需要用一个返回该属性的 getter 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 提供一个 getter 函数</span><br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> obj.<span class="hljs-property">count</span>,<br>  <span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count is: <span class="hljs-subst">$&#123;count&#125;</span>`</span>);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure>

<h2 id="深层监听器"><a href="#深层监听器" class="headerlink" title="深层监听器"></a>深层监听器</h2><p>直接给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br><br><span class="hljs-title function_">watch</span>(obj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在嵌套的属性变更时触发</span><br>  <span class="hljs-comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span><br>  <span class="hljs-comment">// 因为它们是同一个对象！</span><br>&#125;);<br><br>obj.<span class="hljs-property">count</span>++;<br></code></pre></td></tr></table></figure>

<p>相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">someObject</span>,<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 仅当 state.someObject 被替换时触发</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure>

<p>你也可以给上面这个例子显式地加上 deep 选项，强制转成深层侦听器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">someObject</span>,<br>  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span><br>    <span class="hljs-comment">// *除非* state.someObject 被整个替换了</span><br>  &#125;,<br>  &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;<br>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。</p>
</blockquote>
<h2 id="即时回调的监听器"><a href="#即时回调的监听器" class="headerlink" title="即时回调的监听器"></a>即时回调的监听器</h2><p>有的时候我们需要先请求一些数据，然后再进行监听<br>但 <code>watch</code> 默认是懒执行的<br>我们可以通过传入 immediate: true 选项来强制侦听器的回调立即执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">watch</span>(<br>  source,<br>  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 立即执行，且当 `source` 改变时再次执行</span><br>  &#125;,<br>  &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;<br>);<br></code></pre></td></tr></table></figure>

<h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect()"></a>watchEffect()</h2><p>侦听器的回调使用与源完全相同的响应式状态是很常见的。例如下面的代码，在每当 todoId 的引用发生变化时使用侦听器来加载一个远程资源：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> todoId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-title function_">watch</span>(<br>  todoId,<br>  <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<br>      <span class="hljs-string">`https://jsonplaceholder.typicode.com/todos/<span class="hljs-subst">$&#123;todoId.value&#125;</span>`</span><br>    );<br>    data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;,<br>  &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;<br>);<br></code></pre></td></tr></table></figure>

<p>我们可以用 watchEffect 函数 来简化上面的代码。watchEffect() 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<br>    <span class="hljs-string">`https://jsonplaceholder.typicode.com/todos/<span class="hljs-subst">$&#123;todoId.value&#125;</span>`</span><br>  );<br>  data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这个例子中，回调会立即执行，不需要指定 immediate: true。在执行期间，它会自动追踪 todoId.value 作为依赖（和计算属性类似）。每当 todoId.value 变化时，回调会再次执行。有了 watchEffect()，我们不再需要明确传递 todoId 作为源值。</p>
<blockquote>
<p>watchEffect 仅会在其同步执行期间，才追踪依赖。在使用异步回调时，只有在第一个 await 正常工作前访问到的属性才会被追踪。</p>
</blockquote>
<h2 id="watch-vs-watchEffect"><a href="#watch-vs-watchEffect" class="headerlink" title="watch vs. watchEffect"></a>watch vs. watchEffect</h2><p><code>watch</code> 和 <code>watchEffect</code> 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：</p>
<ul>
<li><p><code>watch</code> 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</p>
</li>
<li><p><code>watchEffect</code> ，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。</p>
</li>
</ul>
<h2 id="回调的触发时机"><a href="#回调的触发时机" class="headerlink" title="回调的触发时机"></a>回调的触发时机</h2><p>默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。</p>
<p>如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: ‘post’ 选项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">watch</span>(source, callback, &#123;<br>  <span class="hljs-attr">flush</span>: <span class="hljs-string">&quot;post&quot;</span>,<br>&#125;);<br><br><span class="hljs-title function_">watchEffect</span>(callback, &#123;<br>  <span class="hljs-attr">flush</span>: <span class="hljs-string">&quot;post&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>后置刷新的 watchEffect() 有个更方便的别名 watchPostEffect()：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; watchPostEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-title function_">watchPostEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">/* 在 Vue 更新后执行 */</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="异步监听器"><a href="#异步监听器" class="headerlink" title="异步监听器"></a>异步监听器</h2><p>注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 需要异步请求得到的数据</span><br><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (data.<span class="hljs-property">value</span>) &#123;<br>    <span class="hljs-comment">// 数据加载后执行某些操作...</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h1 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h1><p>虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 ref attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input ref=&quot;input&quot; /&gt;<br></code></pre></td></tr></table></figure>

<h2 id="访问模板引用"><a href="#访问模板引用" class="headerlink" title="访问模板引用"></a>访问模板引用</h2><p>为了通过组合式 API 获得该模板引用，我们需要声明一个同名的 ref：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, onMounted &#125; from &quot;vue&quot;;<br><br>// 声明一个 ref 来存放该元素的引用<br>// 必须和模板里的 ref 同名<br>const input = ref(null);<br><br>onMounted(() =&gt; &#123;<br>  input.value.focus();<br>&#125;);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input ref=&quot;input&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>如果不使用 <code>&lt;script setup&gt;</code>，需确保从 <code>setup()</code> 返回 ref：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> input = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      input,<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>注意，你只可以在组件挂载后才能访问模板引用。如果你想在模板中的表达式上访问 input，在初次渲染时会是 null。这是因为在初次渲染前这个元素还不存在呢！</p>
<h2 id="v-for-中的模板引用"><a href="#v-for-中的模板引用" class="headerlink" title="v-for 中的模板引用"></a>v-for 中的模板引用</h2><p>当在 v-for 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, onMounted &#125; from &quot;vue&quot;;<br><br>const list = ref([<br>  /* ... */<br>]);<br><br>const itemRefs = ref([]);<br><br>onMounted(() =&gt; console.log(itemRefs.value));<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;ul&gt;<br>    &lt;li v-for=&quot;item in list&quot; ref=&quot;itemRefs&quot;&gt;<br>      &#123;&#123; item &#125;&#125;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：ref 数组并不保证与源数组相同的顺序。</p>
</blockquote>
<h2 id="函数模板引用"><a href="#函数模板引用" class="headerlink" title="函数模板引用"></a>函数模板引用</h2><p>除了使用字符串值作名字，ref attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;input :ref=&quot;(el) =&gt; &#123; /* 将 el 赋值给一个数据属性或 ref 变量 */ &#125;&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>注意我们这里需要使用动态的 :ref 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 el 参数会是 null。你当然也可以绑定一个组件方法而不是内联函数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>自此，Vue 相关的基础知识已经学习了大半，但距离开发还远，下一章节将了解一下 Vue 中的组件相关内容</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
        <a href="/tags/Vue/">#Vue</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Vue基础</div>
      <div>https://www.yygod0120.com/2023/06/08/Vue/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>叶</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月8日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年8月25日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/24/%E5%85%B3%E4%BA%8E%E6%9C%9F%E6%9C%AB%E5%91%A8%E5%8A%A0%E8%80%83%E6%A0%B8%E9%80%BC%E6%AD%BB%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%BF%99%E4%BB%B6%E4%BA%8B/" title="关于期末周加考核逼死大学生这件事">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">关于期末周加考核逼死大学生这件事</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/08/Vue%E7%BB%84%E4%BB%B6/" title="Vue组件">
                        <span class="hidden-mobile">Vue组件</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
