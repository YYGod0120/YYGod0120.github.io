

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon-32x32.png">
  <link rel="icon" href="/img/favicon-32x32.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="叶">
  <meta name="keywords" content="">
  
    <meta name="description" content="组件基础与 React 相同，Vue 也是由一个个组件构成一个大的项目，但是与 React 又有些许不同 1.组件的注册一个 Vue 组件在使用前需要先被“注册”，这样 Vue 才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。 全局注册我们可以使用 Vue 应用实例的 app.component() 方法，让组件在当前 Vue 应用中全局可用。 1234567891011">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue组件">
<meta property="og:url" content="https://www.yygod0120.com/2023/06/08/Vue%E7%BB%84%E4%BB%B6/index.html">
<meta property="og:site_name" content="Ye&#39;s Blog">
<meta property="og:description" content="组件基础与 React 相同，Vue 也是由一个个组件构成一个大的项目，但是与 React 又有些许不同 1.组件的注册一个 Vue 组件在使用前需要先被“注册”，这样 Vue 才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。 全局注册我们可以使用 Vue 应用实例的 app.component() 方法，让组件在当前 Vue 应用中全局可用。 1234567891011">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.yygod0120.com/images/Vue%E7%BB%84%E4%BB%B6.jpg">
<meta property="article:published_time" content="2023-06-08T11:56:43.000Z">
<meta property="article:modified_time" content="2023-06-14T13:09:05.831Z">
<meta property="article:author" content="叶">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.yygod0120.com/images/Vue%E7%BB%84%E4%BB%B6.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Vue组件 - Ye&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.yygod0120.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<!-- hexo injector head_end start --><style type="text/css">span[class="simple-icon"]{width:1.2rem;height:1.2rem;display:inline-block}span[class="simple-icon"] svg,img{display:inline-block;vertical-align:middle;height:inherit;width:inherit}</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>YE</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://images.unsplash.com/photo-1677946060093-7c9f0208dab1?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1228&q=80') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Vue组件"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-08 19:56" pubdate>
          2023年6月8日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          189 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Vue组件</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年6月14日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h1><p>与 React 相同，Vue 也是由一个个组件构成一个大的项目，但是与 React 又有些许不同</p>
<h2 id="1-组件的注册"><a href="#1-组件的注册" class="headerlink" title="1.组件的注册"></a>1.组件的注册</h2><p>一个 Vue 组件在使用前需要先被“注册”，这样 Vue 才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。</p>
<h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>我们可以使用 Vue 应用实例的 <code>app.component()</code> 方法，让组件在当前 Vue 应用中全局可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;);<br><br>app.<span class="hljs-title function_">component</span>(<br>  <span class="hljs-comment">// 注册的名字</span><br>  <span class="hljs-string">&quot;MyComponent&quot;</span>,<br>  <span class="hljs-comment">// 组件的实现</span><br>  &#123;<br>    <span class="hljs-comment">/* ... */</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure>

<p>如果使用单文件组件，你可以注册被导入的 .vue 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;<br><br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;MyComponent&quot;</span>, <span class="hljs-title class_">MyComponent</span>);<br></code></pre></td></tr></table></figure>

<p>全局注册的组件可以在此应用的任意组件的模板中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 这在当前应用的任意组件中都可用 --&gt;<br>&lt;ComponentA /&gt;<br>&lt;ComponentB /&gt;<br>&lt;ComponentC /&gt;<br></code></pre></td></tr></table></figure>

<p>所有的子组件也可以使用全局注册的组件，这意味着这三个组件也都可以在彼此内部使用。</p>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>全局注册虽然很方便，但有以下几个问题：</p>
<ul>
<li><p>全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。</p>
</li>
<li><p>全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。</p>
</li>
</ul>
<p>相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。<br>在使用 <code>&lt;script setup&gt;</code> 的单文件组件中，导入的组件可以直接在模板中使用，无需注册：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import ComponentA from &quot;./ComponentA.vue&quot;;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;ComponentA /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>如果没有使用 <code>&lt;script setup&gt;</code>，则需要使用 components 选项来显式注册：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./ComponentA.js&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-title class_">ComponentA</span>, <span class="hljs-comment">//等价于ComponentA: ComponentA</span><br>  &#125;,<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>请注意：<strong>局部注册的组件在后代组件中并不可用</strong>。在这个例子中，ComponentA 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。</p>
<h3 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h3><p>采用首字母大写的驼峰式命名，如 PascalCase，MyComponent 等等</p>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><h3 id="Props-声明"><a href="#Props-声明" class="headerlink" title="Props 声明"></a>Props 声明</h3><p>一个组件需要显式声明它所接受的 props。<br>在使用 <code>&lt;script setup&gt;</code> 的单文件组件中，props 可以使用 defineProps() 宏来声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const props = defineProps([&quot;foo&quot;]);<br><br>console.log(props.foo);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>在没有使用 <code>&lt;script setup&gt;</code> 的组件中，prop 可以使用 props 选项来声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;foo&quot;</span>],<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-comment">// setup() 接收 props 作为第一个参数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props.<span class="hljs-property">foo</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>除了使用字符串数组来声明 prop 外，还可以使用对象的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 &lt;script setup&gt;</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">likes</span>: <span class="hljs-title class_">Number</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 非 &lt;script setup&gt;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">likes</span>: <span class="hljs-title class_">Number</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>对于以对象形式声明中的每个属性，key 是 prop 的名称，而值则是该 prop 预期类型的构造函数。比如，如果要求一个 prop 的值是 number 类型，则可使用 Number 构造函数作为其声明的值。</p>
<h3 id="传递-props-的细节"><a href="#传递-props-的细节" class="headerlink" title="传递 props 的细节"></a>传递 props 的细节</h3><h4 id="Prop-名字格式"><a href="#Prop-名字格式" class="headerlink" title="Prop 名字格式"></a>Prop 名字格式</h4><p>如果一个 prop 的名字很长，应使用 camelCase 形式，因为它们是合法的 JavaScript 标识符，可以直接在模板的表达式中使用，也可以避免在作为属性 key 名时必须加上引号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">greetingMessage</span>: <span class="hljs-title class_">String</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;span&gt;&#123;&#123; greetingMessage &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure>

<p>虽然理论上你也可以在向子组件传递 props 时使用 camelCase 形式 (使用 DOM 模板时例外)，但实际上为了和 HTML attribute 对齐，我们通常会将其写为 kebab-case 形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent greeting-message=&quot;hello&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>对于组件名我们推荐使用 PascalCase，因为这提高了模板的可读性，能帮助我们区分 Vue 组件和原生 HTML 元素。然而对于传递 props 来说，使用 camelCase 并没有太多优势，因此我们推荐更贴近 HTML 的书写风格。</p>
<h4 id="静态-vs-动态-Prop"><a href="#静态-vs-动态-Prop" class="headerlink" title="静态 vs. 动态 Prop"></a>静态 vs. 动态 Prop</h4><p>至此，你已经见过了很多像这样的静态值形式的 props：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BlogPost title=&quot;My journey with Vue&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>相应地，还有使用 v-bind 或缩写 : 来进行动态绑定的 props：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 根据一个变量的值动态传入 --&gt;<br>&lt;BlogPost :title=&quot;post.title&quot; /&gt;<br><br>&lt;!-- 根据一个更复杂表达式的值动态传入 --&gt;<br>&lt;BlogPost :title=&quot;post.title + &#x27; by &#x27; + post.author.name&quot; /&gt;<br></code></pre></td></tr></table></figure>

<h4 id="传递不同值的类型"><a href="#传递不同值的类型" class="headerlink" title="传递不同值的类型"></a>传递不同值的类型</h4><p>在上述的两个例子中，我们只传入了字符串值，但实际上任何类型的值都可以作为 props 的值被传递。</p>
<h4 id="使用一个对象绑定多个-prop"><a href="#使用一个对象绑定多个-prop" class="headerlink" title="使用一个对象绑定多个 prop"></a>使用一个对象绑定多个 prop</h4><p>如果你想要将一个对象的所有属性都当作 props 传入，你可以使用没有参数的 v-bind，即只使用 v-bind 而非 :prop-name。例如，这里有一个 post 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> post = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My Journey with Vue&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>以及下面的模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BlogPost v-bind=&quot;post&quot; /&gt;<br>&lt;!-- 等价于<br>&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;<br>--&gt;<br></code></pre></td></tr></table></figure>

<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的 props 都遵循着单向绑定原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p>
<p>导致你想要更改一个 prop 的需求通常来源于以下两种场景：</p>
<ol>
<li><strong>prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性</strong> 在这种情况下，最好是新定义一个局部数据属性，从 props 上获取初始值即可：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&quot;initialCounter&quot;</span>]);<br><br><span class="hljs-comment">// 计数器只是将 props.initialCounter 作为初始值</span><br><span class="hljs-comment">// 像下面这样做就使 prop 和后续更新无关了</span><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">ref</span>(props.<span class="hljs-property">initialCounter</span>);<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>需要对传入的 prop 值做进一步的转换。</strong>在这种情况中，最好是基于该 prop 值定义一个计算属性：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&quot;size&quot;</span>]);<br><br><span class="hljs-comment">// 该 prop 变更时计算属性也会自动更新</span><br><span class="hljs-keyword">const</span> normalizedSize = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> props.<span class="hljs-property">size</span>.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">toLowerCase</span>());<br></code></pre></td></tr></table></figure>

<h3 id="Boolean-类型转换"><a href="#Boolean-类型转换" class="headerlink" title="Boolean 类型转换"></a>Boolean 类型转换</h3><p>为了更贴近原生 boolean attributes 的行为，声明为 Boolean 类型的 props 有特别的类型转换规则。以带有如下声明的 <code>&lt;MyComponent&gt;</code> 组件为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: <span class="hljs-title class_">Boolean</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>该组件可以被这样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- 等同于传入 :disabled=&quot;true&quot; --&gt;<br>&lt;MyComponent disabled /&gt;<br><br>&lt;!-- 等同于传入 :disabled=&quot;false&quot; --&gt;<br>&lt;MyComponent /&gt;<br></code></pre></td></tr></table></figure>

<p>当一个 prop 被声明为允许多种类型时，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">Number</span>],<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>无论声明类型的顺序如何，Boolean 类型的特殊转换规则都会被应用。</p>
<h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>有的时候我们的子组件需要和父组件进行交互,可以通过事件来进行交互</p>
<h3 id="触发与监听事件"><a href="#触发与监听事件" class="headerlink" title="触发与监听事件"></a>触发与监听事件</h3><p>父组件通过<code>v-on</code>或者<code>@</code>来选择性地监听子组件上抛的事件，就像监听原生 DOM 事件一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BlogPost<br>  ...<br>  @enlarge-text=&quot;postFontSize += 0.1&quot;<br> /&gt;<br></code></pre></td></tr></table></figure>

<p>子组件可以通过调用内置的 $emit 方法，通过传入事件名称来抛出一个事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- BlogPost.vue, 省略了 &lt;script&gt; --&gt;<br>&lt;template&gt;<br>  &lt;div class=&quot;blog-post&quot;&gt;<br>    &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;<br>    &lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;Enlarge text&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h3 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h3><p>有时候我们会需要在触发事件时附带一个特定的值。举例来说，我们想要 <code>&lt;BlogPost&gt;</code> 组件来管理文本会缩放得多大。在这个场景下，我们可以给 $emit 提供一个额外的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;button @click=&quot;$emit(&#x27;increaseBy&#x27;, 1)&quot;&gt;<br>  Increase by 1<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p>然后我们在父组件中监听事件，我们可以先简单写一个内联的箭头函数作为监听器，此函数会接收到事件附带的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyButton @increase-by=&quot;(n) =&gt; count += n&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>或者，也可以用一个组件方法来作为事件处理函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyButton @increase-by=&quot;increaseCount&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>该方法也会接收到事件所传递的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">increaseCount</span>(<span class="hljs-params">n</span>) &#123;<br>  count.<span class="hljs-property">value</span> += n;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="声明触发的事件"><a href="#声明触发的事件" class="headerlink" title="声明触发的事件"></a>声明触发的事件</h3><p>我们可以通过 defineEmits 宏来声明需要抛出的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- BlogPost.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&quot;title&quot;]);<br>defineEmits([&quot;enlarge-text&quot;]);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>这声明了一个组件可能触发的所有事件，还可以对事件的参数进行验证。同时，这还可以让 Vue 避免将它们作为原生事件监听器隐式地应用于子组件的根元素。</p>
<p>和 defineProps 类似，defineEmits 仅可用于 <code>&lt;script setup&gt;</code> 之中，并且不需要导入，它返回一个等同于 $emit 方法的 emit 函数。它可以被用于在组件的 <code>&lt;script setup&gt;</code> 中抛出事件，因为此处无法直接访问 $emit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const emit = defineEmits([&quot;enlarge-text&quot;]);<br><br>emit(&quot;enlarge-text&quot;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>如果你没有在使用 <code>&lt;script setup&gt;</code>，你可以通过 emits 选项定义组件会抛出的事件。你可以从 setup() 函数的第二个参数，即 setup 上下文对象上访问到 emit 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&quot;inFocus&quot;</span>, <span class="hljs-string">&quot;submit&quot;</span>],<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, ctx</span>) &#123;<br>    ctx.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;submit&quot;</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>与 setup() 上下文对象中的其他属性一样，emit 可以安全地被解构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&quot;inFocus&quot;</span>, <span class="hljs-string">&quot;submit&quot;</span>],<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, &#123; emit &#125;</span>) &#123;<br>    <span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;submit&quot;</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="事件检验"><a href="#事件检验" class="headerlink" title="事件检验"></a>事件检验</h3><p>和对 props 添加类型校验的方式类似，所有触发的事件也可以使用对象形式来描述。</p>
<p>要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 emit 的内容，返回一个布尔值来表明事件是否合法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const emit = defineEmits(&#123;<br>  // 没有校验<br>  click: null,<br><br>  // 校验 submit 事件<br>  submit: (&#123; email, password &#125;) =&gt; &#123;<br>    if (email &amp;&amp; password) &#123;<br>      return true;<br>    &#125; else &#123;<br>      console.warn(&quot;Invalid submit event payload!&quot;);<br>      return false;<br>    &#125;<br>  &#125;,<br>&#125;);<br><br>function submitForm(email, password) &#123;<br>  emit(&quot;submit&quot;, &#123; email, password &#125;);<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h2 id="组件中的-v-model"><a href="#组件中的-v-model" class="headerlink" title="组件中的 v-model"></a>组件中的 v-model</h2><p>v-model 组件也可以使用在组件上</p>
<p>当使用在一个组件上时，v-model 会被展开为如下的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;CustomInput<br>  :modelValue=&quot;searchText&quot;<br>  @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;<br>/&gt;<br></code></pre></td></tr></table></figure>

<p>要让这个例子实际工作起来，<code>&lt;CustomInput&gt;</code> 组件内部需要做两件事：</p>
<ol>
<li>将内部原生 <code>&lt;input&gt;</code> 元素的 value attribute 绑定到 modelValue prop</li>
<li>当原生的 input 事件触发时，触发一个携带了新值的 update:modelValue 自定义事件</li>
</ol>
<p>这里是相应的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- CustomInput.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&quot;modelValue&quot;]);<br>defineEmits([&quot;update:modelValue&quot;]);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>现在 v-model 可以在这个组件上正常工作了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;CustomInput v-model=&quot;searchText&quot; /&gt;<br></code></pre></td></tr></table></figure>

<h3 id="v-model-的参数"><a href="#v-model-的参数" class="headerlink" title="v-model 的参数"></a>v-model 的参数</h3><p>默认情况下，v-model 在组件上都是使用 modelValue 作为 prop，并以 update:modelValue 作为对应的事件。我们可以通过给 v-model 指定一个参数来更改这些名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，子组件应声明一个 title prop，并通过触发 update:title 事件更新父组件值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- MyComponent.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&quot;title&quot;]);<br>defineEmits([&quot;update:title&quot;]);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;title&quot;<br>    @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h3 id="多个-v-model-绑定"><a href="#多个-v-model-绑定" class="headerlink" title="多个 v-model 绑定"></a>多个 v-model 绑定</h3><p>利用刚才在 v-model 参数小节中学到的指定参数与事件名的技巧，我们可以在单个组件实例上创建多个 v-model 双向绑定。</p>
<p>组件上的每一个 v-model 都会同步不同的 prop，而无需额外的选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;UserName<br>  v-model:first-name=&quot;first&quot;<br>  v-model:last-name=&quot;last&quot;<br>/&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>defineProps(&#123;<br>  firstName: String,<br>  lastName: String,<br>&#125;);<br><br>defineEmits([&quot;update:firstName&quot;, &quot;update:lastName&quot;]);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;firstName&quot;<br>    @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;<br>  /&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;lastName&quot;<br>    @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h3 id="处理-v-model-修饰符"><a href="#处理-v-model-修饰符" class="headerlink" title="处理 v-model 修饰符"></a>处理 v-model 修饰符</h3><p>在学习输入绑定时，我们知道了 v-model 有一些内置的修饰符，例如 .trim，.number 和 .lazy。在某些场景下，你可能想要一个自定义组件的 v-model 支持自定义的修饰符。</p>
<p>我们来创建一个自定义的修饰符 capitalize，它会自动将 v-model 绑定输入的字符串值第一个字母转为大写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyComponent v-model.capitalize=&quot;myText&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>组件的 v-model 上所添加的修饰符，可以通过 modelModifiers prop 在组件内访问到。在下面的组件中，我们声明了 modelModifiers 这个 prop，它的默认值是一个空对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const props = defineProps(&#123;<br>  modelValue: String,<br>  modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;,<br>&#125;);<br><br>defineEmits([&quot;update:modelValue&quot;]);<br><br>console.log(props.modelModifiers); // &#123; capitalize: true &#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>注意这里组件的 <code>modelModifiers</code> prop 包含了 <code>capitalize</code> 且其值为 true，因为它在模板中的 v-model 绑定 <code>v-model.capitalize=&quot;myText&quot;</code> 上被使用了。</p>
<p>有了这个 prop，我们就可以检查 <code>modelModifiers</code> 对象的键，并编写一个处理函数来改变抛出的值。在下面的代码里，我们就是在每次 <code>&lt;input /&gt;</code> 元素触发 input 事件时将值的首字母大写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const props = defineProps(&#123;<br>  modelValue: String,<br>  modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;,<br>&#125;);<br><br>const emit = defineEmits([&quot;update:modelValue&quot;]);<br><br>function emitValue(e) &#123;<br>  let value = e.target.value;<br>  if (props.modelModifiers.capitalize) &#123;<br>    value = value.charAt(0).toUpperCase() + value.slice(1);<br>  &#125;<br>  emit(&quot;update:modelValue&quot;, value);<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot; /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h2 id="透传-Attributes"><a href="#透传-Attributes" class="headerlink" title="透传 Attributes"></a>透传 Attributes</h2><h3 id="Attributes-继承"><a href="#Attributes-继承" class="headerlink" title="Attributes 继承"></a>Attributes 继承</h3><p>“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。</p>
<p>当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。举例来说，假如我们有一个 <code>&lt;MyButton&gt;</code> 组件，它的模板长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- &lt;MyButton&gt; 的模板 --&gt;<br>&lt;button&gt;click me&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p>一个父组件使用了这个组件，并且传入了 class：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyButton class=&quot;large&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>最后渲染出的 DOM 结果是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;large&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里，<code>&lt;MyButton&gt;</code> 并没有将 class 声明为一个它所接受的 prop，所以 class 被视作透传 attribute，自动透传到了 <code>&lt;MyButton&gt;</code> 的根元素上。</p>
<h4 id="对-class-和-style-的合并"><a href="#对-class-和-style-的合并" class="headerlink" title="对 class 和 style 的合并"></a>对 class 和 style 的合并</h4><p>如果一个子组件的根元素已经有了 class 或 style attribute，它会和从父组件上继承的值合并。如果我们将之前的 <code>&lt;MyButton&gt;</code> 组件的模板改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- &lt;MyButton&gt; 的模板 --&gt;<br>&lt;button class=&quot;btn&quot;&gt;click me&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p>则最后渲染出的 DOM 结果会变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn large&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="v-on-监听器继承"><a href="#v-on-监听器继承" class="headerlink" title="v-on 监听器继承"></a>v-on 监听器继承</h4><p>同样的规则也适用于 v-on 事件监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;MyButton @click=&quot;onClick&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>click 监听器会被添加到 <code>&lt;MyButton&gt;</code> 的根元素，即那个原生的 <code>&lt;button&gt;</code> 元素之上。当原生的 <code>&lt;button&gt;</code> 被点击，会触发父组件的 onClick 方法。同样的，如果原生 button 元素自身也通过 v-on 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。</p>
<h4 id="深层组件继承"><a href="#深层组件继承" class="headerlink" title="深层组件继承"></a>深层组件继承</h4><p>有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 <code>&lt;MyButton&gt;</code>，让它在根节点上渲染 <code>&lt;BaseButton&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;!-- &lt;MyButton/&gt; 的模板，只是渲染另一个组件 --&gt;<br>&lt;BaseButton /&gt;<br></code></pre></td></tr></table></figure>

<p>此时 <code>&lt;MyButton&gt;</code> 接收的透传 <code>attribute</code> 会直接继续传给 <code>&lt;BaseButton&gt;</code>。</p>
<p>请注意：</p>
<ul>
<li><p>透传的 attribute 不会包含 <code>&lt;MyButton&gt;</code> 上声明过的 props 或是针对 emits 声明事件的 v-on 侦听函数，换句话说，声明过的 props 和侦听函数被 <code>&lt;MyButton&gt;</code>“消费”了。</p>
</li>
<li><p>透传的 attribute 若符合声明，也可以作为 props 传入 <BaseButton>。</p>
</li>
</ul>
<h3 id="禁用-Attributes-继承"><a href="#禁用-Attributes-继承" class="headerlink" title="禁用 Attributes 继承"></a>禁用 Attributes 继承</h3><p>如果你不想要一个组件自动地继承 attribute，你可以在组件选项中设置 <code>inheritAttrs: false</code><br>如果你使用了 <code>&lt;script setup&gt;</code>，你需要一个额外的 <code>&lt;script&gt;</code> 块来书写这个选项声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>// 使用普通的 &lt;script&gt; 来声明选项<br>export default &#123;<br>  inheritAttrs: false,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;script setup&gt;<br>// ...setup 部分逻辑<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>从 3.3 开始你也可以直接在 <code>&lt;script setup&gt;</code> 中使用 defineOptions：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>defineOptions(&#123;<br>  inheritAttrs: false,<br>&#125;);<br>// ...setup 逻辑<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 inheritAttrs 选项为 false，你可以完全控制透传进来的 attribute 被如何使用。</p>
<p>这些透传进来的 attribute 可以在模板的表达式中直接用 $attrs 访问到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;span&gt;Fallthrough attribute: &#123;&#123; $attrs &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure>

<p>这个 $attrs 对象包含了除组件所声明的 props 和 emits 之外的所有其他 attribute，例如 class，style，v-on 监听器等等。</p>
<p>有几点需要注意：</p>
<ul>
<li><p>和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 foo-bar 这样的一个 attribute 需要通过 <code>$attrs[&#39;foo-bar&#39;]</code> 来访问。</p>
</li>
<li><p>像 @click 这样的一个 v-on 事件监听器将在此对象下被暴露为一个函数 $attrs.onClick。</p>
</li>
</ul>
<p>现在我们要再次使用一下之前小节中的 <code>&lt;MyButton&gt;</code> 组件例子。有时候我们可能为了样式，需要在 <code>&lt;button&gt;</code> 元素外包装一层 <code>&lt;div&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div class=&quot;btn-wrapper&quot;&gt;<br>  &lt;button class=&quot;btn&quot;&gt;click me&lt;/button&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>我们想要所有像 class 和 v-on 监听器这样的透传 attribute 都应用在内部的 <code>&lt;button&gt;</code> 上而不是外层的 <code>&lt;div&gt;</code> 上。我们可以通过设定 inheritAttrs: false 和使用 <code>v-bind=&quot;$attrs&quot;</code> 来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;btn-wrapper&quot;&gt;<br>  &lt;button class=&quot;btn&quot; v-bind=&quot;$attrs&quot;&gt;click me&lt;/button&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>小提示：没有参数的 v-bind 会将一个对象的所有属性都作为 attribute 应用到目标元素上。</p>
</blockquote>
<h3 id="多根节点的-Attributes-继承"><a href="#多根节点的-Attributes-继承" class="headerlink" title="多根节点的 Attributes 继承"></a>多根节点的 Attributes 继承</h3><p>和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 $attrs 没有被显式绑定，将会抛出一个运行时警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;CustomLayout id=&quot;custom-layout&quot; @click=&quot;changeValue&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>如果 <code>&lt;CustomLayout&gt;</code> 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;header&gt;...&lt;/header&gt;<br>&lt;main&gt;...&lt;/main&gt;<br>&lt;footer&gt;...&lt;/footer&gt;<br></code></pre></td></tr></table></figure>

<p>如果 $attrs 被显式绑定，则不会有警告：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;header&gt;...&lt;/header&gt;<br>&lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;<br>&lt;footer&gt;...&lt;/footer&gt;<br></code></pre></td></tr></table></figure>

<h3 id="在-JavaScript-中访问透传-Attributes"><a href="#在-JavaScript-中访问透传-Attributes" class="headerlink" title="在 JavaScript 中访问透传 Attributes"></a>在 JavaScript 中访问透传 Attributes</h3><p>如果需要，你可以在 <code>&lt;script setup&gt;</code> 中使用 useAttrs() API 来访问一个组件的所有透传 attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; useAttrs &#125; from &quot;vue&quot;;<br><br>const attrs = useAttrs();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>如果没有使用 <code>&lt;script setup&gt;</code>，attrs 会作为 setup() 上下文对象的一个属性暴露：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, ctx</span>) &#123;<br>    <span class="hljs-comment">// 透传 attribute 被暴露为 ctx.attrs</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ctx.<span class="hljs-property">attrs</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，虽然这里的 attrs 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。如果你需要响应性，可以使用 prop。或者你也可以使用 onUpdated() 使得在每次更新时结合最新的 attrs 执行副作用。</p>
<h2 id="插槽内容与出口"><a href="#插槽内容与出口" class="headerlink" title="插槽内容与出口"></a>插槽内容与出口</h2><p>在之前的章节中，我们已经了解到组件能够接收任意类型的 JavaScript 值作为 props，但组件要如何接收模板内容呢？在某些场景中，我们可能想要为子组件传递一些模板片段，让子组件在它们的组件中渲染这些片段。</p>
<p>举例来说，这里有一个 <code>&lt;FancyButton&gt;</code> 组件，可以像这样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;FancyButton&gt;<br>  Click me! &lt;!-- 插槽内容 --&gt;<br>&lt;/FancyButton&gt;<br></code></pre></td></tr></table></figure>

<p>而 <code>&lt;FancyButton&gt;</code> 的模板是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;button class=&quot;fancy-btn&quot;&gt;<br>  &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p><code>&lt;slot&gt;</code> 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染。</p>
<p>最终渲染出的 DOM 是这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fancy-btn&quot;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>插槽内容可以是任意合法的模板内容，不局限于文本。例如我们可以传入多个元素，甚至是组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;FancyButton&gt;<br>  &lt;span style=&quot;color:red&quot;&gt;Click me!&lt;/span&gt;<br>  &lt;AwesomeIcon name=&quot;plus&quot; /&gt;<br>&lt;/FancyButton&gt;<br></code></pre></td></tr></table></figure>

<h3 id="渲染作用域"><a href="#渲染作用域" class="headerlink" title="渲染作用域"></a>渲染作用域</h3><p>插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;<br>&lt;FancyButton&gt;&#123;&#123; message &#125;&#125;&lt;/FancyButton&gt;<br></code></pre></td></tr></table></figure>

<p>这里的两个  插值表达式渲染的内容都是一样的。</p>
<blockquote>
<p>父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。</p>
</blockquote>
<h3 id="默认内容"><a href="#默认内容" class="headerlink" title="默认内容"></a>默认内容</h3><p>在外部没有提供任何内容的情况下，可以为插槽指定默认内容。比如有这样一个 <code>&lt;SubmitButton&gt;</code> 组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;button type=&quot;submit&quot;&gt;<br>  &lt;slot&gt;&lt;/slot&gt;<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p>如果我们想在父组件没有提供任何插槽内容时在 <code>&lt;button&gt;</code> 内渲染“Submit”，只需要将“Submit”写在 <code>&lt;slot&gt;</code> 标签之间来作为默认内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;button type=&quot;submit&quot;&gt;<br>  &lt;slot&gt;<br>    Submit &lt;!-- 默认内容 --&gt;<br>  &lt;/slot&gt;<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>

<p>现在，当我们在父组件中使用 <code>&lt;SubmitButton&gt;</code> 且没有提供任何插槽内容时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;SubmitButton /&gt;<br></code></pre></td></tr></table></figure>

<p>“Submit”将会被作为默认内容渲染：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>但如果我们提供了插槽内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 <code>&lt;BaseLayout&gt;</code> 组件中，有如下模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;container&quot;&gt;<br>  &lt;header&gt;<br>    &lt;!-- 标题内容放这里 --&gt;<br>  &lt;/header&gt;<br>  &lt;main&gt;<br>    &lt;!-- 主要内容放这里 --&gt;<br>  &lt;/main&gt;<br>  &lt;footer&gt;<br>    &lt;!-- 底部内容放这里 --&gt;<br>  &lt;/footer&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>对于这种场景，<code>&lt;slot&gt;</code> 元素可以有一个特殊的 attribute name，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;div class=&quot;container&quot;&gt;<br>  &lt;header&gt;<br>    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;<br>  &lt;/header&gt;<br>  &lt;main&gt;<br>    &lt;slot&gt;&lt;/slot&gt;<br>  &lt;/main&gt;<br>  &lt;footer&gt;<br>    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;<br>  &lt;/footer&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>这类带 name 的插槽被称为具名插槽 (named slots)。没有提供 name 的 <code>&lt;slot&gt;</code> 出口会隐式地命名为“default”。</p>
<p>在父组件中使用 <code>&lt;BaseLayout&gt;</code> 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到具名插槽了：</p>
<p>要为具名插槽传入内容，我们需要使用一个含 v-slot 指令的 <code>&lt;template&gt;</code> 元素，并将目标插槽的名字传给该指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BaseLayout&gt;<br>  &lt;template v-slot:header&gt;<br>    &lt;!-- header 插槽的内容放这里 --&gt;<br>  &lt;/template&gt;<br>&lt;/BaseLayout&gt;<br></code></pre></td></tr></table></figure>

<p>v-slot 有对应的简写 #，因此 <code>&lt;template v-slot:header&gt;</code> 可以简写为 <code>&lt;template #header&gt;</code>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。</p>
<p>下面我们给出完整的、向 <code>&lt;BaseLayout&gt;</code> 传递插槽内容的代码，指令均使用的是缩写形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BaseLayout&gt;<br>  &lt;template #header&gt;<br>    &lt;h1&gt;Here might be a page title&lt;/h1&gt;<br>  &lt;/template&gt;<br><br>  &lt;template #default&gt;<br>    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;<br>    &lt;p&gt;And another one.&lt;/p&gt;<br>  &lt;/template&gt;<br><br>  &lt;template #footer&gt;<br>    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;<br>  &lt;/template&gt;<br>&lt;/BaseLayout&gt;<br></code></pre></td></tr></table></figure>

<p>当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 <code>&lt;template&gt;</code> 节点都被隐式地视为默认插槽的内容。所以上面也可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;BaseLayout&gt;<br>  &lt;template #header&gt;<br>    &lt;h1&gt;Here might be a page title&lt;/h1&gt;<br>  &lt;/template&gt;<br><br>  &lt;!-- 隐式的默认插槽 --&gt;<br>  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;<br>  &lt;p&gt;And another one.&lt;/p&gt;<br><br>  &lt;template #footer&gt;<br>    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;<br>  &lt;/template&gt;<br>&lt;/BaseLayout&gt;<br></code></pre></td></tr></table></figure>

<p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将被传递到相应的插槽。最终渲染出的 HTML 如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h3><p>动态指令参数在 v-slot 上也是有效的，即可以定义下面这样的动态插槽名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs template">&lt;base-layout&gt;<br>  &lt;template v-slot:[dynamicSlotName]&gt;<br>    ...<br>  &lt;/template&gt;<br><br>  &lt;!-- 缩写为 --&gt;<br>  &lt;template #[dynamicSlotName]&gt;<br>    ...<br>  &lt;/template&gt;<br>&lt;/base-layout&gt;<br></code></pre></td></tr></table></figure>

<p>注意这里的表达式和动态指令参数受相同的语法限制。</p>
<h2 id="Prop-逐级透传问题"><a href="#Prop-逐级透传问题" class="headerlink" title="Prop 逐级透传问题"></a>Prop 逐级透传问题</h2><p>通常情况下，当我们需要从父组件向子组件传递数据时，会使用 props。想象一下这样的结构：有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去，这会非常麻烦：</p>
<p><img src="/2023/06/08/Vue%E7%BB%84%E4%BB%B6/provide1.png" srcset="/img/loading.gif" lazyload alt="逐级传递"></p>
<p>注意，虽然这里的 <code>&lt;Footer&gt;</code> 组件可能根本不关心这些 props，但为了使 <code>&lt;DeepChild&gt;</code> 能访问到它们，仍然需要定义并向下传递。如果组件链路非常长，可能会影响到更多这条路上的组件。这一问题被称为“prop 逐级透传”，显然是我们希望尽量避免的情况。</p>
<p><code>provide</code> 和 <code>inject</code> 可以帮助我们解决这一问题。一个父组件相对于其所有的后代组件，会作为<strong>依赖提供者</strong>。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖。<br><img src="/2023/06/08/Vue%E7%BB%84%E4%BB%B6/provide2.png" srcset="/img/loading.gif" lazyload alt="依赖注入"></p>
<h3 id="1-Provide-提供"><a href="#1-Provide-提供" class="headerlink" title="1.Provide(提供)"></a>1.Provide(提供)</h3><p>要为组件后代提供数据，需要使用到 <code>provide()</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; provide &#125; from &quot;vue&quot;;<br><br>provide(/* 注入名 */ &quot;message&quot;, /* 值 */ &quot;hello!&quot;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>如果不使用 <code>&lt;script setup&gt;</code>，请确保 provide() 是在 setup() 同步调用的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">provide</span>(<span class="hljs-comment">/* 注入名 */</span> <span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-comment">/* 值 */</span> <span class="hljs-string">&quot;hello!&quot;</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>provide() 函数接收两个参数。第一个参数被称为注入名，可以是一个字符串或是一个 Symbol。后代组件会用注入名来查找期望注入的值。一个组件可以多次调用 provide()，使用不同的注入名，注入不同的依赖值。</p>
<p>第二个参数是提供的值，值可以是任意类型，包括响应式的状态，比如一个 ref：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;key&quot;</span>, count);<br></code></pre></td></tr></table></figure>

<p>提供的响应式状态使后代组件可以由此和提供者建立响应式的联系。</p>
<h4 id="应用层-Provide"><a href="#应用层-Provide" class="headerlink" title="应用层 Provide"></a>应用层 Provide</h4><p>除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;);<br><br>app.<span class="hljs-title function_">provide</span>(<span class="hljs-comment">/* 注入名 */</span> <span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-comment">/* 值 */</span> <span class="hljs-string">&quot;hello!&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写插件时会特别有用，因为插件一般都不会使用组件形式来提供值。</p>
<h3 id="2-Inject-注入"><a href="#2-Inject-注入" class="headerlink" title="2.Inject(注入)"></a>2.Inject(注入)</h3><p>要注入上层组件提供的数据，需使用 inject() 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; inject &#125; from &quot;vue&quot;;<br><br>const message = inject(&quot;message&quot;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>如果提供的值是一个 ref，注入进来的会是该 ref 对象，而<strong>不会</strong>自动解包为其内部的值。这使得注入方组件能够通过 ref 对象保持了和供给方的响应性链接。<br>同样的，如果没有使用 <code>&lt;script setup&gt;</code>，inject() 需要在 setup() 内同步调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;message&quot;</span>);<br>    <span class="hljs-keyword">return</span> &#123; message &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="和响应式数据配合使用"><a href="#和响应式数据配合使用" class="headerlink" title="和响应式数据配合使用"></a>和响应式数据配合使用</h3><p>当提供 / 注入响应式的数据时，<strong>建议尽可能将任何对响应式状态的变更都保持在供给方组件中</strong>。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。</p>
<p>有的时候，我们可能需要在注入方组件中更改数据。在这种情况下，我们推荐在供给方组件内声明并提供一个更改数据的方法函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 在供给方组件内 --&gt;<br>&lt;script setup&gt;<br>import &#123; provide, ref &#125; from &quot;vue&quot;;<br><br>const location = ref(&quot;North Pole&quot;);<br><br>function updateLocation() &#123;<br>  location.value = &quot;South Pole&quot;;<br>&#125;<br><br>provide(&quot;location&quot;, &#123;<br>  location,<br>  updateLocation,<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 在注入方组件 --&gt;<br>&lt;script setup&gt;<br>import &#123; inject &#125; from &quot;vue&quot;;<br><br>const &#123; location, updateLocation &#125; = inject(&quot;location&quot;);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;updateLocation&quot;&gt;&#123;&#123; location &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>最后，如果你想确保提供的数据不能被注入方的组件更改，你可以使用 readonly() 来包装提供的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, provide, readonly &#125; from &quot;vue&quot;;<br><br>const count = ref(0);<br>provide(&quot;read-only-count&quot;, readonly(count));<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h3 id="使用-Symbol-作注入名"><a href="#使用-Symbol-作注入名" class="headerlink" title="使用 Symbol 作注入名"></a>使用 Symbol 作注入名</h3><p>至此，我们已经了解了如何使用字符串作为注入名。但如果你正在构建大型的应用，包含非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突。</p>
<p>我们通常推荐在一个单独的文件中导出这些注入名 Symbol：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// keys.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myInjectionKey = <span class="hljs-title class_">Symbol</span>();<br><br><span class="hljs-comment">// 在供给方组件中</span><br><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./keys.js&quot;</span>;<br><br><span class="hljs-title function_">provide</span>(myInjectionKey, &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  要提供的数据</span><br><span class="hljs-comment">*/</span><br>&#125;);<br><br><span class="hljs-comment">// 注入方组件</span><br><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./keys.js&quot;</span>;<br><br><span class="hljs-keyword">const</span> injected = <span class="hljs-title function_">inject</span>(myInjectionKey);<br></code></pre></td></tr></table></figure>

<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...从服务器获取组件</span><br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-comment">/* 获取到的组件 */</span>);<br>  &#125;);<br>&#125;);<br><span class="hljs-comment">// ... 像使用其他一般组件一样使用 `AsyncComp`</span><br></code></pre></td></tr></table></figure>

<p>如你所见，defineAsyncComponent 方法接收一个返回 Promise 的加载函数。这个 Promise 的 resolve 回调方法应该在从服务器获得组件定义时调用。你也可以调用 reject(reason) 表明加载失败。</p>
<p>ES 模块动态导入也会返回一个 Promise，所以多数情况下我们会将它和 defineAsyncComponent 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span><br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./components/MyComponent.vue&quot;</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>最后得到的 AsyncComp 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。</p>
<p>与普通组件一样，异步组件可以使用 app.component() 全局注册：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">component</span>(<br>  <span class="hljs-string">&quot;MyComponent&quot;</span>,<br>  <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./components/MyComponent.vue&quot;</span>))<br>);<br></code></pre></td></tr></table></figure>

<p>也可以直接在父组件中直接定义它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; defineAsyncComponent &#125; from &quot;vue&quot;;<br><br>const AdminPage = defineAsyncComponent(() =&gt;<br>  import(&quot;./components/AdminPageComponent.vue&quot;)<br>);<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;AdminPage /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h3 id="加载与错误状态"><a href="#加载与错误状态" class="headerlink" title="加载与错误状态"></a>加载与错误状态</h3><p>异步操作不可避免地会涉及到加载和错误状态，因此 defineAsyncComponent() 也支持在高级选项中处理这些状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;<br>  <span class="hljs-comment">// 加载函数</span><br>  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./Foo.vue&quot;</span>),<br><br>  <span class="hljs-comment">// 加载异步组件时使用的组件</span><br>  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span>,<br>  <span class="hljs-comment">// 展示加载组件前的延迟时间，默认为 200ms</span><br>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,<br><br>  <span class="hljs-comment">// 加载失败后展示的组件</span><br>  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorComponent</span>,<br>  <span class="hljs-comment">// 如果提供了一个 timeout 时间限制，并超时了</span><br>  <span class="hljs-comment">// 也会显示这里配置的报错组件，默认值是：Infinity</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。</p>
<p>如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
        <a href="/tags/Vue/">#Vue</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Vue组件</div>
      <div>https://www.yygod0120.com/2023/06/08/Vue组件/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>叶</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月8日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年6月14日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/08/Vue/" title="Vue基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Vue基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/05/Redux/" title="Redux">
                        <span class="hidden-mobile">Redux</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
